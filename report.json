[
  {
    "coverage": {
      "files": {
        "codigo.c": {
          "coverage_stats": {
            "covered_lines": 6,
            "total_hits": 6
          },
          "covered_lines": {
            "20": {
              "covered": true,
              "hits": 1,
              "type": "execution"
            },
            "21": {
              "covered": true,
              "hits": 1,
              "type": "execution"
            },
            "31": {
              "covered": true,
              "hits": 1,
              "type": "execution"
            },
            "36": {
              "covered": true,
              "hits": 1,
              "type": "violation"
            },
            "42": {
              "covered": true,
              "hits": 1,
              "type": "execution"
            },
            "46": {
              "covered": true,
              "hits": 1,
              "type": "execution"
            }
          }
        }
      }
    },
    "initial_values": {
      "h": {
        "name": "h",
        "type": "unknown(12)",
        "value": "1.401298e-45f"
      },
      "t": {
        "name": "t",
        "type": "unknown(12)",
        "value": "1.401298e-45f"
      }
    },
    "source_files": {
      "codigo.c": [
        "// versao_para_analise.c",
        "#include <stdio.h>",
        "#include <math.h> // Para isnan",
        "",
        "// Funções \"nondet\" dizem ao ESBMC para testar com QUALQUER valor possível",
        "float nondet_float();",
        "int nondet_int();",
        "",
        "// 1. SIMULAMOS as funções de hardware com \"stubs\" (versões vazias ou simples)",
        "void client_publish(const char* topic, const char* payload) {",
        "    // No teste, não precisamos realmente publicar.",
        "    // Podemos verificar se o payload não é nulo.",
        "    __ESBMC_assert(payload != 0, \"Payload não pode ser nulo\");",
        "}",
        "",
        "// 2. RECRIAMOS A LÓGICA PRINCIPAL dentro de uma função main() padrão",
        "int main() {",
        "    // Simula a leitura dos sensores com valores não determinísticos.",
        "    // O ESBMC vai testar o que acontece com valores normais, infinitos, NaN, etc.",
        "    float h = nondet_float();",
        "    float t = nondet_float();",
        "",
        "    // Valida a leitura (exatamente como no seu código original)",
        "    if (isnan(h) || isnan(t)) {",
        "        printf(\"Falha ao ler do DHT (simulado)\\n\");",
        "        return 0; // Termina a execução se a leitura falhar",
        "    }",
        "",
        "    // Formata o JSON (exatamente como no seu código original)",
        "    char payload[64];",
        "    int len = snprintf(payload, sizeof(payload), \"{\\\"temp\\\":%.2f,\\\"hum\\\":%.2f}\", t, h);",
        "",
        "    // 3. ADICIONAMOS VERIFICAÇÕES (ASSERTS) que o ESBMC pode testar",
        "    // Esta é a parte mais poderosa: criamos propriedades para verificar.",
        "    // Aqui, verificamos se a formatação do snprintf não causou um buffer overflow.",
        "    __ESBMC_assert(len < sizeof(payload), \"Verificação de buffer overflow no payload\");",
        "    ",
        "    if (len > 0 && len < (int)sizeof(payload)) {",
        "        client_publish(\"home/esp/dht\", payload);",
        "        printf(\"Publicado (simulado): %s\\n\", payload);",
        "    } else {",
        "        printf(\"Erro ao formatar payload (simulado)\\n\");",
        "    }",
        "    ",
        "    return 0;",
        "}"
      ]
    },
    "status": "violation",
    "steps": [
      {
        "assignment": {
          "lhs": "h",
          "lhs_type": "unknown(12)",
          "rhs": "1.401298e-45f",
          "rhs_type": "unknown(12)"
        },
        "file": "codigo.c",
        "function": "main",
        "line": "20",
        "step_number": 0,
        "type": "assignment"
      },
      {
        "assignment": {
          "lhs": "t",
          "lhs_type": "unknown(12)",
          "rhs": "1.401298e-45f",
          "rhs_type": "unknown(12)"
        },
        "file": "codigo.c",
        "function": "main",
        "line": "21",
        "step_number": 1,
        "type": "assignment"
      },
      {
        "file": "codigo.c",
        "function": "main",
        "line": "31",
        "step_number": 2,
        "type": "other"
      },
      {
        "assertion": {
          "comment": "Verificação de buffer overflow no payload",
          "guard": "(unsigned long int)len < 64",
          "violated": true
        },
        "file": "codigo.c",
        "function": "main",
        "line": "36",
        "message": "Verificação de buffer overflow no payload",
        "step_number": 3,
        "type": "violation"
      },
      {
        "file": "codigo.c",
        "function": "main",
        "line": "42",
        "step_number": 4,
        "type": "other"
      },
      {
        "file": "codigo.c",
        "function": "main",
        "line": "46",
        "message": "Assumption restriction",
        "step_number": 5,
        "type": "assume"
      }
    ]
  }
]
